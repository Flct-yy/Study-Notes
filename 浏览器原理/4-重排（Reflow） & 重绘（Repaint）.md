核心口诀（先记死，面试直接用）：**Reflow（重排）改几何，Repaint（重绘）改外观；重排必重绘，重绘不必然**。

通俗类比：把浏览器渲染页面想象成“装修房子”——布局（Layout）是确定家具（元素）的摆放位置、大小，绘制（Paint）是给家具刷漆、装装饰。重排就是挪家具、改家具尺寸（要重新规划摆放），重绘就是只换漆色、不挪位置，理解这个类比，所有知识点都能串起来。

专业定义速记（面试直接背）：
- Reflow（重排）：元素**几何信息**发生变化，浏览器需要**重新计算布局**；
- Repaint（重绘）：元素**外观样式**变化，但**不影响布局**。

# 一、浏览器为什么要做 Reflow / Repaint？（面试基础题铺垫）

先搞懂浏览器渲染的核心两步（通俗+专业结合）：

1. **Layout（布局阶段）**：专业说“计算元素的盒模型位置、尺寸”，通俗说“确定每个元素在页面上占多大地方、放哪儿”，这是渲染的基础；

2. **Paint（绘制阶段）**：专业说“将布局后的元素渲染到屏幕，填充颜色、阴影、边框等视觉属性”，通俗说“给确定好位置和大小的元素‘上色、加装饰’，让它显示出来”。

当我们修改 DOM 结构或 CSS 样式时，浏览器会根据修改的类型，决定走哪一步：

- 如果修改影响了“布局”（比如改元素宽度、挪位置），浏览器必须重新走「Layout 阶段」，这就是**Reflow（重排）**；

- 如果修改只影响“外观”（比如改颜色、加阴影），不影响布局，浏览器就跳过 Layout 阶段，直接走「Paint 阶段」，这就是 **Repaint（重绘）**。

关键结论（必背）：**重排一定会触发重绘（挪了家具，肯定要重新刷漆），但重绘不一定触发重排（只刷漆，不用挪家具）**。

# 二、什么是 Reflow（重排）？（面试重点，核心考点）

## 1. 面试标准版定义（直接背诵，不改动）

Reflow（重排）是当元素的**尺寸、位置、结构**发生变化时，浏览器需要重新计算**部分或全部布局树**的过程，是浏览器渲染中性能开销较高的操作。

## 2. 核心特点（面试加分点，通俗解读）

- **性能代价极高**：计算布局需要消耗大量浏览器资源，比重绘耗时得多；

- **影响范围可大可小**：轻则只影响当前元素及其子元素（比如改一个按钮的尺寸），重则影响整个页面（比如改 body 的宽度）；

- 前端性能优化的“重点打击对象”：频繁重排会导致页面卡顿、掉帧，面试聊性能优化，必提“减少重排”。

## 3. 触发 Reflow 的常见操作（必背，面试高频提问）

分4类整理，每类配代码示例，好记不混淆，面试被问“哪些操作会触发重排”，直接按这个框架答：

### （1）修改元素几何属性（最直观，必记）

只要改了“影响元素大小、位置”的样式，都触发重排，代码示例（面试可简述代码逻辑）：

```javascript
// 改宽度、高度
el.style.width = '200px';
el.style.height = '100px';
// 改外边距、内边距
el.style.margin = '20px';
el.style.padding = '10px';
// 改定位偏移量
el.style.top = '50px';
el.style.left = '30px';
```

### （2）修改布局相关的 CSS 样式（易忽略，必记）

这些样式直接控制元素的布局规则，修改后必然触发重排，重点记以下几个（高频）：

```css
/* 布局核心属性，修改即重排 */
display: none; /* 重点，和visibility区分 */
position: absolute; /* 改定位方式 */
float: left; /* 浮动会影响布局 */
clear: both; /* 清除浮动，影响布局 */
/* 弹性盒、网格布局相关 */
flex: 1;
grid-template-columns: 1fr 2fr;
```

### （3）修改 DOM 结构（高频，必记）

添加、删除、移动 DOM 元素，会改变页面的布局结构，必然触发重排，代码示例：

```javascript
// 添加子元素
parent.appendChild(child);
// 删除子元素
parent.removeChild(child);
// 移动元素（剪切粘贴）
parent.insertBefore(child, anotherChild);
```

### （4）读取布局相关信息（面试陷阱，重中之重）

这是最容易被忽略的点，很多人不知道“读属性也会触发重排”，面试高频追问！

原因（通俗解读）：浏览器为了给你返回“最新、最准确”的布局信息，会强制结算之前所有未执行的样式修改，触发一次同步重排，相当于“你问浏览器元素多大，浏览器必须先重新算一遍，才能告诉你”。

常见需避免频繁读取的属性（必背）：

```javascript
el.offsetTop; // 元素距离顶部的偏移量
el.offsetWidth; // 元素宽度（含边框、内边距）
el.clientHeight; // 元素高度（不含边框）
el.scrollTop; // 元素滚动距离
el.getBoundingClientRect(); // 获取元素坐标、尺寸（高频）
```

## 4. Reflow 示例（面试可直接口述，简单好记）

```javascript
const box = document.getElementById('box');
box.style.width = '200px';
```

执行过程（面试口述版）：修改 box 的 width → 元素几何信息变化 → 浏览器重新计算 box 的尺寸和位置 → 若 box 后面有其他元素，可能还要调整这些元素的布局 → 触发 Reflow（重排），之后再触发 Repaint（重绘）。

# 三、什么是 Repaint（重绘）？（面试重点，对比重排记忆）

## 1. 面试标准版定义（直接背诵）

Repaint（重绘）是元素的**视觉样式**发生变化，但不影响其**布局结构**，浏览器无需重新计算布局，只需重新绘制元素像素的过程。

## 2. 核心特点（对比重排，易记）

- 性能代价低于重排：无需计算布局，只需要重新绘制视觉属性，耗时较短；

- 不影响其他元素：因为布局不变，只修改当前元素的外观，不会牵连其他元素；

- 并非“无代价”：频繁重绘也会影响性能，只是比重排的影响小。

## 3. 触发 Repaint 的常见操作（必记，对比重排）

只要改“不影响布局”的视觉样式，都触发重绘，代码示例+CSS属性整理：

```javascript
// 改颜色、背景色（最常见）
el.style.color = 'red';
el.style.backgroundColor = 'blue';
// 改阴影、边框颜色
el.style.boxShadow = '0 0 10px #000';
el.style.borderColor = 'green';
// 改可见性（重点，和display:none区分）
el.style.visibility = 'hidden';
```

高频 CSS 触发属性（必记）：color、background、box-shadow、border-color、visibility、outline。

## 4. 重点对比（面试必考，直接背）

三个易混淆属性的区别，记准表格，面试被问直接答：

|CSS 属性|是否占位|是否触发 Reflow（重排）|是否触发 Repaint（重绘）|
|---|---|---|---|
|display: none|❌ 不占位（元素消失，释放空间）|✅ 触发重排|✅ 触发重绘|
|visibility: hidden|✅ 占位（元素隐藏，但空间保留）|❌ 不触发重排|✅ 触发重绘|
|opacity: 0|✅ 占位（元素透明，空间保留）|❌ 不触发重排|✅ 触发重绘|

通俗解读：display: none 是“把家具搬走”（占的地方没了，其他家具要挪位置 → 重排）；visibility: hidden 和 opacity: 0 是“把家具盖起来”（位置还在，只是看不见，不用挪家具 → 不重排，只重绘）。

## 5. Repaint 示例（面试可直接口述）

```javascript
const box = document.getElementById('box');
box.style.background = 'red';
```

执行过程（面试口述版）：修改 box 的背景色 → 元素的尺寸、位置没有变化（布局不变） → 浏览器跳过 Layout 阶段，直接重新绘制 box 的背景色 → 仅触发 Repaint（重绘），不触发 Reflow（重排）。

# 四、Reflow 为什么这么慢？（面试追问重点）

面试官大概率会追问“重排为什么耗性能”，按这个逻辑答（通俗+专业，好记）：

1. 重排是**递归计算**：页面的元素是嵌套关系（比如 div 里套 span，span 里套 img），父元素的布局变化，会导致所有子元素、后代元素的布局都要重新计算（比如改父 div 的宽度，里面所有子元素的位置可能都要变）；

2. 浏览器需要“全流程重新执行”：重排会触发 Layout 阶段重新计算，计算完成后，还要执行 Paint 阶段（重绘），相当于“走了两次渲染关键步骤”；

3. 页面越复杂，耗时越长：如果页面有大量元素（比如长列表），一次重排可能需要计算上百个元素的布局，性能开销会急剧增加，甚至导致页面卡顿。

# 五、强制同步布局（Layout Thrashing）（面试高频难点，必背）

## 1. 什么是强制同步布局？（通俗解读+代码示例）

通俗说：“频繁交替读取布局属性、修改样式”，导致浏览器频繁触发同步重排，性能直接爆炸，这就是强制同步布局，也叫 Layout Thrashing。

反面示例（面试说“这种写法要避免”）：

```javascript
const box = document.getElementById('box');
// 循环1000次，交替读、写
for (let i = 0; i < 1000; i++) {
  box.style.width = i + 'px'; // 写样式（可能触发重排）
  console.log(box.offsetWidth); // 读布局属性（强制触发重排）
}
```

问题分析（面试口述）：每次循环，先修改 width（样式修改，浏览器会标记“需要重排”，但不会立即执行），然后读取 offsetWidth（浏览器为了返回准确值，会强制执行重排），循环1000次，就触发了1000次重排，页面会严重卡顿。

## 2. 正确写法（面试必背，优化方案）

核心原则：**读写分离**（先一次性读取所有需要的布局属性，再一次性修改样式），避免交替读写。

```javascript
const box = document.getElementById('box');
// 第一步：先一次性读取布局属性（只触发1次重排，甚至不触发）
let width = box.offsetWidth;
// 第二步：再一次性修改样式（只触发1次重排）
for (let i = 0; i < 1000; i++) {
  box.style.width = width + i + 'px';
}
```

优化原理（面试加分）：先读取 offsetWidth，浏览器触发1次重排（如果之前有未执行的样式修改，会一次性结算），之后循环只修改样式，浏览器会批量处理这些修改，最后只触发1次重排，总共只触发2次重排，性能大幅提升。

# 六、如何减少 Reflow / Repaint？（面试核心加分点，必背）

按“易操作、高频考点”排序，每个方案配通俗解读+代码示例，面试被问“如何优化重排重绘”，直接按这个框架答，清晰有条理。

## 1. 批量修改样式（最易实现，必记）

避免多次单独修改 style 属性，改为批量修改（两种方式，任选其一）。

反面示例（❌ 避免）：

```javascript
// 多次修改style，触发多次重排
el.style.width = '100px';
el.style.height = '100px';
el.style.margin = '10px';
```

正面示例（✅ 推荐，两种方式）：

```javascript
// 方式1：使用cssText批量设置
el.style.cssText = 'width:100px;height:100px;margin:10px;';

// 方式2：添加class（更规范，推荐）
el.classList.add('active');
// CSS中定义样式
.active {
  width: 100px;
  height: 100px;
  margin: 10px;
}
```

## 2. 脱离文档流后再操作（高频考点）

通俗解读：把要修改的元素“暂时移出页面布局”，修改完成后再“放回去”，这样修改过程中，不会影响其他元素的布局，只触发2次重排（移出、放回），避免多次重排。

常用方法（✅ 必记）：

```javascript
// 1. 先隐藏元素（display: none，脱离文档流）
el.style.display = 'none';
// 2. 批量修改样式（此时修改不触发重排，因为元素不在布局中）
el.style.width = '200px';
el.style.height = '200px';
el.style.background = 'red';
// 3. 再显示元素（放回文档流，触发1次重排）
el.style.display = 'block';
```

## 3. 使用 transform / opacity 替代传统样式修改（性能最优，面试高频）

核心考点（必背）：transform 和 opacity 的修改，**不触发 Reflow，也不触发 Repaint**，只触发“合成阶段”（GPU 加速），性能最优。

示例（✅ 推荐）：

```css
/* 移动元素：用transform，不触发重排重绘 */
.el {
  transform: translateX(100px) translateY(50px);
}
/* 改变透明度：用opacity，不触发重排重绘 */
.el {
  opacity: 0.5;
}
```

面试追问应答：“为什么 transform 性能好？” → 答：“transform 不参与浏览器的布局计算（Layout 阶段），也不参与绘制（Paint 阶段），只在渲染的最后一步‘合成阶段’执行，由 GPU 加速渲染，所以不会触发重排和重绘，性能远优于传统的 margin、top 等属性修改。”

## 4. 避免频繁读取布局属性（规避强制同步布局）

核心原则：读写分离（前面已讲），另外，尽量缓存布局属性，避免重复读取。

## 5. 减少 DOM 操作（辅助优化）

比如：批量添加 DOM 元素时，先用 DocumentFragment 暂存，再一次性插入页面（减少多次插入触发的重排）；避免频繁删除、移动 DOM 元素。

# 七、面试常考问题（必背，直接对应应答，无需临场组织语言）

以下问题按“高频程度”排序，每个问题配“面试安全应答”（直接背诵），兼顾专业和通俗，避免卡顿。

## 1. 请解释一下 Reflow（重排）和 Repaint（重绘）的区别？（基础必考题）

应答：Reflow 是元素的几何信息（尺寸、位置、结构）发生变化，浏览器需要重新计算布局的过程；Repaint 是元素的外观样式变化，但不影响布局，浏览器只需重新绘制像素的过程。核心区别是是否影响布局，关键结论是：重排一定会触发重绘，重绘不一定触发重排。

## 2. 哪些操作会触发 Reflow（重排）？（高频必考题）

应答：主要分4类：① 修改元素几何属性（如 width、height、margin）；② 修改布局相关 CSS 样式（如 display、position、float、flex 相关）；③ 修改 DOM 结构（如添加、删除、移动子元素）；④ 频繁读取布局属性（如 offsetWidth、clientHeight、getBoundingClientRect()），会触发强制同步重排。

## 3. display: none、visibility: hidden、opacity: 0 的区别？（必考对比题）

应答：从三个维度区分：① 是否占位：display: none 不占位，visibility: hidden 和 opacity: 0 占位；② 是否触发重排：display: none 触发重排，后两者不触发；③ 是否触发重绘：三者都触发重绘。简单记：display 是“搬走家具”，visibility 和 opacity 是“盖住家具”。

## 4. 为什么 Reflow 的性能开销比 Repaint 大？（追问高频题）

应答：因为 Reflow 是递归计算的过程，父元素布局变化会导致所有子元素、后代元素的布局重新计算；而且重排会触发浏览器重新执行 Layout（布局）和 Paint（重绘）两个阶段，而重绘只需要执行 Paint 阶段，无需计算布局；页面元素越多，重排的计算量越大，性能开销就越高。

## 5. 什么是强制同步布局（Layout Thrashing）？如何避免？（难点高频题）

应答：强制同步布局是频繁交替读取布局属性和修改样式，导致浏览器频繁触发同步重排的现象。避免方法是“读写分离”：先一次性读取所有需要的布局属性，缓存起来，再一次性修改样式，避免交替进行读写操作。

## 6. 如何减少 Reflow 和 Repaint？（核心优化题）

应答：主要有5种方法：① 批量修改样式（用 cssText 或添加 class）；② 脱离文档流后操作（先 display: none，修改后再显示）；③ 用 transform 和 opacity 替代传统样式修改，利用 GPU 加速；④ 避免频繁读取布局属性，做好读写分离；⑤ 减少 DOM 操作，批量处理 DOM 元素。

## 7. 为什么 transform 不会触发 Reflow 和 Repaint？（追问加分题）

应答：因为 transform 不参与浏览器的 Layout（布局）计算和 Paint（绘制）阶段，只在渲染的最后一步“合成阶段”执行，由 GPU 负责渲染，不会影响元素的布局和外观绘制，所以既不触发重排，也不触发重绘。

# 八、面试安全版总结（最后背诵，快速复盘）

1. 核心区别：改几何 → 重排（贵），改外观 → 重绘（便宜）；重排必重绘，重绘不必然；

2. 性能重点：重排是性能杀手，强制同步布局会加剧性能问题；

3. 优化核心：减少重排次数，避免频繁读写布局属性，优先用 transform / opacity 做样式修改；

4. 必考对比：记准 display、visibility、opacity 的三者区别，面试直接套用应答模板。